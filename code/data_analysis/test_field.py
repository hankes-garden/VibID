import numpy as np
import matplotlib.pyplot as plt
from scipy.fftpack import fft
import math

def undersampling():
    dSamplingFreq = 1000.0
    arrTime = np.linspace(0.01, 2.0, 2*dSamplingFreq)

    f = 10+100*arrTime
    A = 30 * arrTime 
    
    y = A * np.sin(2.0*np.pi*f*arrTime)
    
    plt.figure()
    plt.subplot(211)
    plt.plot(arrTime, y)

    
    # fft
    arrFreqData = fft(y)
    arrNormalizedPower = abs(arrFreqData)/len(y)
    
    plt.subplot(212)
    arrFreqIndex = np.linspace(0.01, dSamplingFreq/2.0, len(arrNormalizedPower)/2.0)
    plt.plot(arrFreqIndex, arrNormalizedPower[0:len(arrNormalizedPower)/2] )
    plt.show()
    

    
   
def simulateResponse():
    """
        This function simulate the respoonse of human arm, according to
        the formula of vibration generated by ERM and forced vibration
        equation of SDOF object.
    """
    
    dSamplingFreq = 500.0
    arrTime = np.linspace(0.0, 12, 12*dSamplingFreq) # time

    # input voltage increases with time
    nPointPerSecond = int(dSamplingFreq)
#    arrInputVoltage = np.array([30]*2*nPointPerSecond + [40]*2*nPointPerSecond + \
#                      [50]*2*nPointPerSecond + [60]*2*nPointPerSecond + \
#                      [70]*2*nPointPerSecond + [80]*2*nPointPerSecond)
                      
    arrInputVoltage = np.array([30]*3*nPointPerSecond + [50]*3*nPointPerSecond + \
                      [70]*3*nPointPerSecond + [90]*3*nPointPerSecond)
    
    # the relationship btw vibration frequency and input voltage
    # is estimated via experiments
    arrVibFrequency = 0.9125* arrInputVoltage - 3.875
    
    # F = m*r*w^2, where m in KG, r in meter, and w in rad/sec
    arrVibForce = 0.01 * 0.02 * \
                  (arrVibFrequency*2.0*np.pi)**2.0  # excitation amplititude
                                                    # increases with time
                  
                  
    # plot input force
    plt.figure()
    plt.plot(arrTime, arrVibForce)
    plt.figure()
    plt.plot(arrTime, arrVibForce*np.sin(2*np.pi*arrVibFrequency*arrTime))
    plt.show()
        
    # response vs. mass
    xi = 0.1    # damping ratio
    k = 5000.0   # stiffness
    plt.figure()
    for m in np.linspace(1.0, 3.0, 2):
        wn = math.sqrt(k/m)
        arrResponseAmplitude = (arrVibForce / k) * \
        (1 / np.sqrt( (1.0-(arrVibFrequency/wn)**2.0)**2.0 + \
        (2.0*xi*(arrVibFrequency/wn) )**2.0 ) )
   
        plt.plot(arrTime, arrResponseAmplitude, 
                 alpha = 0.7, lw=2,
                 label="m=%.2f, wn=%.2f"%(m, wn ) )
    plt.legend(loc="left_upper")
    plt.show()
    
   
    # reponse vs stiffness
    xi = 0.1
    m = 1.5
    plt.figure()
    for k in np.linspace(4000.0, 7000.0, 2):
        wn = math.sqrt(k/m)
        arrResponseAmplitude = (arrVibForce / k) * \
        (1 / np.sqrt( (1.0-(arrVibFrequency/wn)**2.0)**2.0 + \
        (2.0*xi*(arrVibFrequency/wn) )**2.0 ) )
   
        plt.plot(arrTime, arrResponseAmplitude, 
                 alpha = 0.7, lw=2,
                 label="k=%.2f, wn=%.2f"%(k, wn ) )
    plt.legend(loc="left_upper")
    plt.show()
    

    

if __name__ == "__main__":
    simulateResonance()